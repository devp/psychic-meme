/*
 * font.h — Built-in 5×7 bitmap font and text rendering
 *
 * ═══════════════════════════════════════════════════════════════════
 * THE FONT
 * ═══════════════════════════════════════════════════════════════════
 *
 * Each glyph is a 5-pixel-wide, 7-pixel-tall bitmap stored as 7 bytes.
 * Within each byte, the 5 most-significant bits represent columns
 * left-to-right:
 *
 *     bit 4 (0x10) = leftmost column
 *     bit 3 (0x08) = second column
 *     bit 2 (0x04) = centre column
 *     bit 1 (0x02) = fourth column
 *     bit 0 (0x01) = rightmost column
 *
 * For example, the letter 'A' (index 65−32 = 33):
 *
 *     {0x0E, 0x11, 0x11, 0x1F, 0x11, 0x11, 0x11}
 *
 *     row 0:  0x0E = 01110  →  .XXX.
 *     row 1:  0x11 = 10001  →  X...X
 *     row 2:  0x11 = 10001  →  X...X
 *     row 3:  0x1F = 11111  →  XXXXX
 *     row 4:  0x11 = 10001  →  X...X
 *     row 5:  0x11 = 10001  →  X...X
 *     row 6:  0x11 = 10001  →  X...X
 *
 * The font covers printable ASCII (space=32 through tilde=126).
 * Characters outside this range silently render as a space.
 *
 * ═══════════════════════════════════════════════════════════════════
 * TEXT RENDERING
 * ═══════════════════════════════════════════════════════════════════
 *
 * fb_char()           — Render one glyph at (px, py).  The `scale`
 *                       parameter integer-scales each pixel, so
 *                       scale=2 produces 10×14 characters.
 *
 * fb_string()         — Walk a C string, rendering each character
 *                       with 6×scale pixel advance (5 glyph + 1 gap).
 *
 * fb_string_width()   — Return the pixel width a string would occupy
 *                       at a given scale.  Used for centring.
 *
 * fb_string_centered()— Render a string horizontally centred on the
 *                       framebuffer at a given y coordinate.
 *
 * fb_degree()         — Render a tiny 3×3 degree symbol (°).  This
 *                       is separate from the main font because the
 *                       degree sign needs to sit at the top of the
 *                       line, superscript-style.
 */

#ifndef FONT_H
#define FONT_H

#include "fb.h"
#include <string.h>

/* ── glyph data: ASCII 32 (' ') through 126 ('~') ──────────────── */
/*
 * 95 glyphs × 7 bytes = 665 bytes.  This table is const and lives
 * in the read-only data segment.
 */
static const uint8_t font5x7[][7] = {
    /* 32 ' ' */ {0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    /* 33 '!' */ {0x04,0x04,0x04,0x04,0x04,0x00,0x04},
    /* 34 '"' */ {0x0A,0x0A,0x00,0x00,0x00,0x00,0x00},
    /* 35 '#' */ {0x0A,0x1F,0x0A,0x0A,0x1F,0x0A,0x00},
    /* 36 '$' */ {0x04,0x0F,0x14,0x0E,0x05,0x1E,0x04},
    /* 37 '%' */ {0x18,0x19,0x02,0x04,0x08,0x13,0x03},
    /* 38 '&' */ {0x08,0x14,0x14,0x08,0x15,0x12,0x0D},
    /* 39 ''' */ {0x04,0x04,0x00,0x00,0x00,0x00,0x00},
    /* 40 '(' */ {0x02,0x04,0x08,0x08,0x08,0x04,0x02},
    /* 41 ')' */ {0x08,0x04,0x02,0x02,0x02,0x04,0x08},
    /* 42 '*' */ {0x00,0x04,0x15,0x0E,0x15,0x04,0x00},
    /* 43 '+' */ {0x00,0x04,0x04,0x1F,0x04,0x04,0x00},
    /* 44 ',' */ {0x00,0x00,0x00,0x00,0x00,0x04,0x08},
    /* 45 '-' */ {0x00,0x00,0x00,0x1F,0x00,0x00,0x00},
    /* 46 '.' */ {0x00,0x00,0x00,0x00,0x00,0x00,0x04},
    /* 47 '/' */ {0x01,0x01,0x02,0x04,0x08,0x10,0x10},
    /* 48 '0' */ {0x0E,0x11,0x13,0x15,0x19,0x11,0x0E},
    /* 49 '1' */ {0x04,0x0C,0x04,0x04,0x04,0x04,0x0E},
    /* 50 '2' */ {0x0E,0x11,0x01,0x06,0x08,0x10,0x1F},
    /* 51 '3' */ {0x0E,0x11,0x01,0x06,0x01,0x11,0x0E},
    /* 52 '4' */ {0x02,0x06,0x0A,0x12,0x1F,0x02,0x02},
    /* 53 '5' */ {0x1F,0x10,0x1E,0x01,0x01,0x11,0x0E},
    /* 54 '6' */ {0x06,0x08,0x10,0x1E,0x11,0x11,0x0E},
    /* 55 '7' */ {0x1F,0x01,0x02,0x04,0x08,0x08,0x08},
    /* 56 '8' */ {0x0E,0x11,0x11,0x0E,0x11,0x11,0x0E},
    /* 57 '9' */ {0x0E,0x11,0x11,0x0F,0x01,0x02,0x0C},
    /* 58 ':' */ {0x00,0x00,0x04,0x00,0x00,0x04,0x00},
    /* 59 ';' */ {0x00,0x00,0x04,0x00,0x00,0x04,0x08},
    /* 60 '<' */ {0x02,0x04,0x08,0x10,0x08,0x04,0x02},
    /* 61 '=' */ {0x00,0x00,0x1F,0x00,0x1F,0x00,0x00},
    /* 62 '>' */ {0x08,0x04,0x02,0x01,0x02,0x04,0x08},
    /* 63 '?' */ {0x0E,0x11,0x01,0x02,0x04,0x00,0x04},
    /* 64 '@' */ {0x0E,0x11,0x17,0x15,0x17,0x10,0x0E},
    /* 65 'A' */ {0x0E,0x11,0x11,0x1F,0x11,0x11,0x11},
    /* 66 'B' */ {0x1E,0x11,0x11,0x1E,0x11,0x11,0x1E},
    /* 67 'C' */ {0x0E,0x11,0x10,0x10,0x10,0x11,0x0E},
    /* 68 'D' */ {0x1E,0x11,0x11,0x11,0x11,0x11,0x1E},
    /* 69 'E' */ {0x1F,0x10,0x10,0x1E,0x10,0x10,0x1F},
    /* 70 'F' */ {0x1F,0x10,0x10,0x1E,0x10,0x10,0x10},
    /* 71 'G' */ {0x0E,0x11,0x10,0x17,0x11,0x11,0x0F},
    /* 72 'H' */ {0x11,0x11,0x11,0x1F,0x11,0x11,0x11},
    /* 73 'I' */ {0x0E,0x04,0x04,0x04,0x04,0x04,0x0E},
    /* 74 'J' */ {0x07,0x02,0x02,0x02,0x02,0x12,0x0C},
    /* 75 'K' */ {0x11,0x12,0x14,0x18,0x14,0x12,0x11},
    /* 76 'L' */ {0x10,0x10,0x10,0x10,0x10,0x10,0x1F},
    /* 77 'M' */ {0x11,0x1B,0x15,0x15,0x11,0x11,0x11},
    /* 78 'N' */ {0x11,0x19,0x15,0x13,0x11,0x11,0x11},
    /* 79 'O' */ {0x0E,0x11,0x11,0x11,0x11,0x11,0x0E},
    /* 80 'P' */ {0x1E,0x11,0x11,0x1E,0x10,0x10,0x10},
    /* 81 'Q' */ {0x0E,0x11,0x11,0x11,0x15,0x12,0x0D},
    /* 82 'R' */ {0x1E,0x11,0x11,0x1E,0x14,0x12,0x11},
    /* 83 'S' */ {0x0E,0x11,0x10,0x0E,0x01,0x11,0x0E},
    /* 84 'T' */ {0x1F,0x04,0x04,0x04,0x04,0x04,0x04},
    /* 85 'U' */ {0x11,0x11,0x11,0x11,0x11,0x11,0x0E},
    /* 86 'V' */ {0x11,0x11,0x11,0x11,0x0A,0x0A,0x04},
    /* 87 'W' */ {0x11,0x11,0x11,0x15,0x15,0x1B,0x11},
    /* 88 'X' */ {0x11,0x11,0x0A,0x04,0x0A,0x11,0x11},
    /* 89 'Y' */ {0x11,0x11,0x0A,0x04,0x04,0x04,0x04},
    /* 90 'Z' */ {0x1F,0x01,0x02,0x04,0x08,0x10,0x1F},
    /* 91 '[' */ {0x0E,0x08,0x08,0x08,0x08,0x08,0x0E},
    /* 92 '\' */ {0x10,0x10,0x08,0x04,0x02,0x01,0x01},
    /* 93 ']' */ {0x0E,0x02,0x02,0x02,0x02,0x02,0x0E},
    /* 94 '^' */ {0x04,0x0A,0x11,0x00,0x00,0x00,0x00},
    /* 95 '_' */ {0x00,0x00,0x00,0x00,0x00,0x00,0x1F},
    /* 96 '`' */ {0x08,0x04,0x00,0x00,0x00,0x00,0x00},
    /* 97 'a' */ {0x00,0x00,0x0E,0x01,0x0F,0x11,0x0F},
    /* 98 'b' */ {0x10,0x10,0x1E,0x11,0x11,0x11,0x1E},
    /* 99 'c' */ {0x00,0x00,0x0E,0x11,0x10,0x11,0x0E},
    /*100 'd' */ {0x01,0x01,0x0F,0x11,0x11,0x11,0x0F},
    /*101 'e' */ {0x00,0x00,0x0E,0x11,0x1F,0x10,0x0E},
    /*102 'f' */ {0x06,0x08,0x1E,0x08,0x08,0x08,0x08},
    /*103 'g' */ {0x00,0x00,0x0F,0x11,0x0F,0x01,0x0E},
    /*104 'h' */ {0x10,0x10,0x1E,0x11,0x11,0x11,0x11},
    /*105 'i' */ {0x04,0x00,0x0C,0x04,0x04,0x04,0x0E},
    /*106 'j' */ {0x02,0x00,0x06,0x02,0x02,0x12,0x0C},
    /*107 'k' */ {0x10,0x10,0x12,0x14,0x18,0x14,0x12},
    /*108 'l' */ {0x0C,0x04,0x04,0x04,0x04,0x04,0x0E},
    /*109 'm' */ {0x00,0x00,0x1A,0x15,0x15,0x15,0x15},
    /*110 'n' */ {0x00,0x00,0x1E,0x11,0x11,0x11,0x11},
    /*111 'o' */ {0x00,0x00,0x0E,0x11,0x11,0x11,0x0E},
    /*112 'p' */ {0x00,0x00,0x1E,0x11,0x1E,0x10,0x10},
    /*113 'q' */ {0x00,0x00,0x0F,0x11,0x0F,0x01,0x01},
    /*114 'r' */ {0x00,0x00,0x16,0x19,0x10,0x10,0x10},
    /*115 's' */ {0x00,0x00,0x0F,0x10,0x0E,0x01,0x1E},
    /*116 't' */ {0x08,0x08,0x1E,0x08,0x08,0x09,0x06},
    /*117 'u' */ {0x00,0x00,0x11,0x11,0x11,0x11,0x0F},
    /*118 'v' */ {0x00,0x00,0x11,0x11,0x0A,0x0A,0x04},
    /*119 'w' */ {0x00,0x00,0x11,0x11,0x15,0x15,0x0A},
    /*120 'x' */ {0x00,0x00,0x11,0x0A,0x04,0x0A,0x11},
    /*121 'y' */ {0x00,0x00,0x11,0x11,0x0F,0x01,0x0E},
    /*122 'z' */ {0x00,0x00,0x1F,0x02,0x04,0x08,0x1F},
    /*123 '{' */ {0x02,0x04,0x04,0x08,0x04,0x04,0x02},
    /*124 '|' */ {0x04,0x04,0x04,0x04,0x04,0x04,0x04},
    /*125 '}' */ {0x08,0x04,0x04,0x02,0x04,0x04,0x08},
    /*126 '~' */ {0x00,0x00,0x08,0x15,0x02,0x00,0x00},
};

/* ── fb_char: render a single glyph into the framebuffer ────────── */
/*
 * px, py  — top-left pixel position of the character
 * ch      — ASCII character to draw
 * fg      — foreground colour
 * scale   — integer magnification (1 = native 5×7, 2 = 10×14, etc.)
 *
 * For each "on" pixel in the 5×7 bitmap, we fill a scale×scale
 * block of framebuffer pixels with the foreground colour.  This
 * gives us arbitrary-size text from a single font definition.
 *
 * The bit-test expression (0x10 >> col) walks columns left-to-right:
 *   col=0 → test bit 4 (0x10)  = leftmost pixel
 *   col=1 → test bit 3 (0x08)
 *   col=2 → test bit 2 (0x04)  = centre pixel
 *   col=3 → test bit 1 (0x02)
 *   col=4 → test bit 0 (0x01)  = rightmost pixel
 */
static void fb_char(int px, int py, char ch, rgb_t fg, int scale) {
    int idx = ch - 32;
    if (idx < 0 || idx > 94) idx = 0;  /* out-of-range → space */
    for (int row = 0; row < 7; row++)
        for (int col = 0; col < 5; col++)
            if (font5x7[idx][row] & (0x10 >> col))
                for (int sy = 0; sy < scale; sy++)
                    for (int sx = 0; sx < scale; sx++) {
                        int fx = px + col * scale + sx;
                        int fy = py + row * scale + sy;
                        if (fx >= 0 && fx < FB_W && fy >= 0 && fy < FB_H)
                            fb[fy][fx] = fg;
                    }
}

/* ── fb_string: render a NUL-terminated string ──────────────────── */
/*
 * Each character occupies 6×scale pixels horizontally (5 glyph
 * pixels + 1 pixel gap between characters).
 */
static void fb_string(int px, int py, const char *s, rgb_t fg, int scale) {
    int spacing = 6 * scale;
    for (; *s; s++, px += spacing)
        fb_char(px, py, *s, fg, scale);
}

/* ── fb_string_width: compute rendered width in pixels ──────────── */
static int fb_string_width(const char *s, int scale) {
    return (int)strlen(s) * 6 * scale;
}

/* ── fb_string_centered: render a string centred on the display ─── */
static void fb_string_centered(int y, const char *s, rgb_t fg, int scale) {
    int w = fb_string_width(s, scale);
    fb_string((FB_W - w) / 2, y, s, fg, scale);
}

/* ── fb_degree: render a small superscript degree symbol (°) ────── */
/*
 * The degree symbol is a 3×3 bitmap forming a tiny circle:
 *     .X.     → 0x02
 *     X.X     → 0x05
 *     .X.     → 0x02
 *
 * It's rendered the same way as font glyphs (scale×scale blocks),
 * but using a separate 3-byte bitmap because it doesn't fit the
 * 5×7 grid neatly and needs to sit at the top of the line.
 */
static void fb_degree(int px, int py, rgb_t fg, int scale) {
    static const uint8_t deg[3] = {0x02, 0x05, 0x02};
    for (int row = 0; row < 3; row++)
        for (int col = 0; col < 3; col++)
            if (deg[row] & (0x04 >> col))
                for (int sy = 0; sy < scale; sy++)
                    for (int sx = 0; sx < scale; sx++) {
                        int fx = px + col * scale + sx;
                        int fy = py + row * scale + sy;
                        if (fx >= 0 && fx < FB_W && fy >= 0 && fy < FB_H)
                            fb[fy][fx] = fg;
                    }
}

#endif /* FONT_H */
